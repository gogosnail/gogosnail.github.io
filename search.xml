<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Android-技术干货】Touch事件在Window间穿透]]></title>
    <url>%2F2019%2F02%2F25%2F%E3%80%90Android-%E6%8A%80%E6%9C%AF%E5%B9%B2%E8%B4%A7%E3%80%91Touch%E4%BA%8B%E4%BB%B6%E5%9C%A8Window%E9%97%B4%E7%A9%BF%E9%80%8F%2F</url>
    <content type="text"><![CDATA[1.解决了什么问题？在某些场景下，希望当前的Window只处理部分区域的Touch事件，而把Window中其他区域的收到的事件，“穿透”到下层的其他Window中。例如：桌面悬浮窗需要全屏展示，但是只有一部分区域是可以点击的，其他的区域需要将事件交给其他应用去处理，这时候就可以用到本文的方案。 2.解决思路首先，需要知道Android的Window对事件的处理，是由ViewTreeObserver中的OnComputeInternalInsetsListener来确定的，所以，需要修改OnComputeInternalInsetsListener回调里的InternalInsetsInfo参数来设置事件的点击区域。接下来，就是怎么修改OnComputeInternalInsetsListener的问题。先来看下ViewTreeObserver的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public final class ViewTreeObserver &#123; ... private CopyOnWriteArray&lt;OnComputeInternalInsetsListener&gt; mOnComputeInternalInsetsListeners; ... /** * Interface definition for a callback to be invoked when layout has * completed and the client can compute its interior insets. * ... * @hide */ public interface OnComputeInternalInsetsListener &#123; /** * Callback method to be invoked when layout has completed and the * client can compute its interior insets. * * @param inoutInfo Should be filled in by the implementation with * the information about the insets of the window. This is called * with whatever values the previous OnComputeInternalInsetsListener * returned, if there are multiple such listeners in the window. */ public void onComputeInternalInsets(InternalInsetsInfo inoutInfo); &#125; ... /** * Register a callback to be invoked when the invoked when it is time to * compute the window's internal insets. * ... * @hide */ public void addOnComputeInternalInsetsListener(OnComputeInternalInsetsListener listener) &#123; checkIsAlive(); if (mOnComputeInternalInsetsListeners == null) &#123; mOnComputeInternalInsetsListeners = new CopyOnWriteArray&lt;OnComputeInternalInsetsListener&gt;(); &#125; mOnComputeInternalInsetsListeners.add(listener); &#125; /** * Remove a previously installed internal insets computation callback * ... * @hide */ public void removeOnComputeInternalInsetsListener(OnComputeInternalInsetsListener victim) &#123; checkIsAlive(); if (mOnComputeInternalInsetsListeners == null) &#123; return; &#125; mOnComputeInternalInsetsListeners.remove(victim); &#125; ... 从源码里可以看到，我们需要创建一个OnComputeInternalInsetsListener，然后将它添加到mOnComputeInternalInsetsListeners中就能实现事件穿透。然而，OnComputeInternalInsetsListener类以及与它相关的方法都是hide的。因此，一般的调用是满足不了的，我们只能使用其他方法，那就是暴力的反射。确定了反射的方案后，我们分两步：第一步是创建OnComputeInternalInsetsListener，对于隐藏的类实例，我们可以利用Java的动态代理来实现。 123456public class OnComputeInternalInsetsListener implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; ... &#125;&#125; 第二步是把创建的实例添加到mOnComputeInternalInsetsListeners，这一步就比较简单了，只需要对addOnComputeInternalInsetsListener方法进行反射调用就可以了。以上就是事件在Window间实现穿透的实现思路。 3.代码 OnComputeInternalInsetsListener动态代理: 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class OnComputeInternalInsetsListener implements InvocationHandler &#123; private Region touchRegion = null; public Object getListener() &#123; Object target = null; try &#123; Class class1 = Class.forName("android.view.ViewTreeObserver$OnComputeInternalInsetsListener"); target = Proxy.newProxyInstance(OnComputeInternalInsetsListener.class.getClassLoader(), new Class[]&#123;class1&#125;, this); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return target; &#125; public Region getTouchRegion() &#123; return touchRegion; &#125; public void setTouchRegion(Region touchRegion) &#123; this.touchRegion = touchRegion; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) &#123; try &#123; Field regionField = args[0].getClass() .getDeclaredField("touchableRegion"); regionField.setAccessible(true); Field insetField = args[0].getClass() .getDeclaredField("mTouchableInsets"); insetField.setAccessible(true); if (touchRegion != null) &#123; Region region = (Region) regionField.get(args[0]); region.set(touchRegion); insetField.set(args[0], InputMethodService.Insets.TOUCHABLE_INSETS_REGION); &#125; else &#123; insetField.set(args[0], InputMethodService.Insets.TOUCHABLE_INSETS_FRAME); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; addOnComputeInternalInsetsListener和removeOnComputeInternalInsetsListener方法反射: 1234567891011121314151617181920212223242526272829303132333435public static void removeOnComputeInternalInsetsListener(ViewTreeObserver viewTree) &#123; if (viewTree == null) &#123; return; &#125; try &#123; Class&lt;?&gt; clazz = Class.forName("android.view.ViewTreeObserver"); Field field = viewTree.getClass().getDeclaredField("mOnComputeInternalInsetsListeners"); field.setAccessible(true); Object listenerList = field.get(viewTree); Method method = listenerList.getClass().getDeclaredMethod("getArray"); method.setAccessible(true); ArrayList&lt;Object&gt; list = (ArrayList&lt;Object&gt;) method.invoke(listenerList); Class&lt;?&gt; classes[] = &#123;Class.forName("android.view.ViewTreeObserver$OnComputeInternalInsetsListener")&#125;; if (list != null &amp;&amp; list.size() &gt; 0) &#123; clazz.getDeclaredMethod("removeOnComputeInternalInsetsListener", classes).invoke(viewTree, list.get(0)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void addOnComputeInternalInsetsListener(ViewTreeObserver viewTree, Object object) &#123; if (viewTree == null) &#123; return; &#125; try &#123; Class&lt;?&gt; classes[] = &#123;Class.forName("android.view.ViewTreeObserver$OnComputeInternalInsetsListener")&#125;; Class&lt;?&gt; clazz = Class.forName("android.view.ViewTreeObserver"); clazz.getDeclaredMethod("addOnComputeInternalInsetsListener", classes).invoke(viewTree, object); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 给RootView设置指定的点击区域 123456private void configTouch() &#123; mInvocationHandler = new OnComputeInternalInsetsListener(); ReflectionUtils.removeOnComputeInternalInsetsListener(mRootView.getViewTreeObserver()); ReflectionUtils.addOnComputeInternalInsetsListener(mRootView.getViewTreeObserver(), mInvocationHandler.getListener()); mInvocationHandler.setTouchRegion(mTouchRegion);&#125; 4.Demo下载下载地址 5.Window可接受Touch事件区域的系统源码可以查阅源码中的ViewRootImpl类，下面是关键源码。123456789101112131415161718192021222324252627282930313233343536373839404142public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; private void performTraversals() &#123; ... if (computesInternalInsets) &#123; // Clear the original insets. final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets; insets.reset(); // Compute new insets in place. mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets); mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty(); // Tell the window manager. if (insetsPending || !mLastGivenInsets.equals(insets)) &#123; mLastGivenInsets.set(insets); // Translate insets to screen coordinates if needed. final Rect contentInsets; final Rect visibleInsets; final Region touchableRegion; if (mTranslator != null) &#123; contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets); visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets); touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion); &#125; else &#123; contentInsets = insets.contentInsets; visibleInsets = insets.visibleInsets; touchableRegion = insets.touchableRegion; &#125; try &#123; mWindowSession.setInsets(mWindow, insets.mTouchableInsets, contentInsets, visibleInsets, touchableRegion); &#125; catch (RemoteException e) &#123; &#125; &#125; &#125; ... &#125; ...&#125;]]></content>
      <categories>
        <category>技术干货</category>
      </categories>
      <tags>
        <tag>-Android -技术干货</tag>
      </tags>
  </entry>
</search>
